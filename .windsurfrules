1. Задания считается выполненым только если изменив функциональность ты изменил тесты связынные с этой функциональностью, запустил тесты и они полностью выполнились без ошибок, а если с ошибками ты исправляешь ошибки до тех пор пока они не выполнятся без ошибок.
2. Для баз данных используй Alembic + SQLAlchemy
3. Везде руководствуйся принципом DRY - Dont Repeat Yourself
4. Руководствуйся принципом разделения слоев: бизнес-логика, валидация, хендлеры, роуты, вьюхи, везде отдельно. Делай хороший нейминг. Бизнес логику пиши в отдельных файлах, Файлы с endpoint делай простыми и понятными. 
5. Телеграмм-бота пиши с помощью aiogram
6. Весь код должен быть асинхронным
7. Используй версию python 3.13.0
8. Используй переменные окружения через .env если тебе нужно, но в таком случае не забудь добавить .env в .gitignore. Если 
используешь .env то создай .env.example
9. Используй .gitignore для защиты от чувствительных данных(такик как файл .env) и чтобы не было мусора(например pycache)

# Бизнес-задача

Реализовать телеграмм-бота куда может зайти любой желающий таксист. 

После регистрации, а именно выбора языка, страны и города, где он находится, пользователь может каждый день указывать свое рабочее время.

А также мониторить за количеством людей, которые также зашли в этот телеграм-бот в его городе, и суммарным количеством нерабочих часов в его городе.

## ТЗ

### Интерфейс

Телеграмм-бот

### Флоу использования

Нажать кнопку **START**.

Далее выбрать свой язык. Язык может быть: польский, русский, английский, украинский, турецкий. Выбрать его по кнопке.

**Далее**.

Выбрать страну. Это может быть европейская страна. Для начала давайте остановимся на Польше. А дальше выбрать город. В данной стране один из списка городов:

const polishCities = [
"Warszawa",
"Kraków",
"Wrocław",
"Poznań",
"Gdańsk",
"Łódź",
"Szczecin",
"Lublin",
"Katowice",
"Bydgoszcz",
"Białystok",
"Gdynia",
"Częstochowa",
"Radom",
"Sosnowiec",
"Toruń",
"Olsztyn",
"Opole",
"Zielona Góra",
"Tychy"
];

Основная задача бота — это вносить время своей работы. Необходимо каждый день начиная с 0.00 по местному времени (учесть часовой 

пояс), снова вносить свое рабочее время на предстоящий день. Это может быть как один, так и два, так и три промежутка времени, но 

не более 3.

Например: с 9 до 11 и с 15 до 20 / с 12 до 19 /  с 10 до 11 и с 15 до 17 и с 20 до 24

Свое рабочее время можно вносить только один раз. После этого никакую информацию вносить нельзя. Любые попытки внести информацию 

должны сопровождаться сообщением, что следующий раз внести свое рабочее время можно на следующий день.

Помимо этого, в телеграм-боте должно отображаться две метрики.

Первая — это общее количество человек, которые нажали кнопку START в его городе. А второе — это суммарное количество нерабочих часов в его городе. Количество нерабочих часов для города А рассчитывается по формуле: а1+а2+а3+…+аN, где а1 - это количество нерабочих часов для конкретного пользователя из города А. Данное время рассчитывается по формуле: 24 часа - (количество рабочих часов за сутки, которое было внесено).

Примечание: Метрика под названием "суммарное количество нерабочих часов" будет возрастать каждый день с нуля до своего 

максимального значения в 23:59. В 00:00 бот отправляет пользователю сообщение что он готов принимать новые рабочие часы

То есть она считается на текущий момент, сколько людей в данном городе уже внесли свои рабочие часы на сегодня. Если, например, до 

часа ночи никто не внесет свои рабочие часы на предстоящий день, то, соответственно, общее суммарное количество будет равно нулю.

Данные 2 метрики должны обновляться каждые 10 минут.

Пример отображения метрик:

В городе Варшава участвуют человек: 133 

Суммарное количество нерабочих часов за сегодня в городе Варшава: 435 ч.

# Таблицы для базы данных
таблица users:
1. telegram_user_id
2. city_id(foreign_key из таблицы cities)
3. language


Структура БД:

таблица users:
1. telegram_user_id(primary key)
2. city_id(foreign_key из таблицы cities)
3. language

таблица working_hours:
1. telegram_user_id(primary key, foreign_key из telegram_user_id)
2. date
3. first_working_hours_begin
4. first_working_hours_end
5. second_working_hours_begin
6. second_working_hours_end
7. third_working_hours_begin
8. third_working_hours_end
9. fourth_working_hours_begin
10. fourth_working_hours_end
11. unworking_hours
12. working_hours


таблица cities:
1. city_id(primary key)
2. city_name

таблица users_in_cities:
1. city_id(primary key, foreign_key из cities)
2. users_count

В 8, 15, 21 и 24 часа нужно отправлять админ-пользователю отчет. Отчет состоит из гистограммы. Задача гистограммы — это 

визуализировать рабочее время всех пользователей в текущем городе, чтобы определить время, когда меньше всего работает людей, или 

время, когда больше всего работает. 

telegram_id админа - 1079270402

# Пример реализации гистограммы:

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

data = [
    ['8:00', '11:00', '14:00', '18:00'],
    ['9:00', '16:00'],
    ['7:00', '10:00', '14:00', '16:00'],
    ['8:00', '10:00', '13:00', '17:00'],
    ['10:00', '11:00', '13:00', '20:00'],
    ['14:00', '23:00']
]

def extract_hours(row):
    hours = []
    for i in range(0, len(row), 2):
        if i+1 < len(row) and row[i] and row[i+1]:
            start = int(row[i].split(':')[0])
            end = int(row[i+1].split(':')[0])
            hours.extend(range(start, end))
    return hours

hour_counts = {}
for row in data:
    row_hours = extract_hours(row)
    for h in row_hours:
        hour_counts[h] = hour_counts.get(h, 0) + 1

all_hours = list(range(6, 24))
counts = [hour_counts.get(h, 0) for h in all_hours]

df = pd.DataFrame({'Hour': all_hours, 'People Working': counts})

plt.figure(figsize=(10, 5))
plt.bar(df['Hour'], df['People Working'])
plt.xticks(df['Hour'])
plt.xlabel('Hour of Day')
plt.ylabel('Number of People Working')
plt.title('Work Activity by Hour')
plt.grid(True)
plt.tight_layout()
plt.show()











